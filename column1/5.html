<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

	<title>Book</title>

	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css">
	<link rel="stylesheet" href="../css/index.css">
</head>
<body>

<div class="container">
	<div class="row">

		<pre></pre>
		<code></code>

		<div class="center">
			<h1>Big-O Notation</h1>
			<p>
				Big O notation is one of the most fundamental tools for computer scientists to analyze the cost of an algorithm.
				It is a good practice for software engineers to understand in-depth as well.
				Understand how to analyze an implementation of an algorithm with respect to both time (execution time) and space (memory consumed).
				The question asked with Big-O is the following: “What will happen as n approaches infinity?”.
				Алгоритмы описывают с помощью двух характеристик — времени и памяти.
				Другими словами: насколько возрастет кол-во операций при увеличении кол-ва входных параметров.
			</p>
		</div>

		<div>
			<h2><strong>Introduction</strong></h2>
		</div>
		<blockquote class="blockquote full-with">
			Big-O Complexity Chart
			<pre>
				<div>
          <svg id="chart" width="800" height="500" xmlns="http://www.w3.org/2000/svg">
            <!-- horrible region -->
            <path d="M50 450 L 50 0 L 800 0 L 800 450 Z" fill="#ff8989"></path>
			  <!-- bad region -->
            <path d="M50 450 L 800 0 L 800 450 Z" fill="#FFC543"></path>
			  <!-- fair region -->
            <path d="M50 450 L 800 450 L 800 330 Z" fill="yellow"></path>
			  <!-- good region -->
            <path d="M50 450 L 800 450 L 800 410 Z" fill="#C8EA00"></path>
			  <!-- excellent region -->
            <path d="M50 450 L 800 450 L 800 440 Z" fill="#53d000"></path>

			  <!-- axes -->
            <path d="M50 0 L 50 450 L 800 450" fill="transparent" stroke="black" stroke-width="2"></path>

            <path d="M50 448 L 800 448" fill="transparent" stroke="black" stroke-width="2"></path>
            <text x="700" y="438" fill="black">O(log n), O(1)</text>

            <path d="M50 450 L 800 400" fill="transparent" stroke="black" stroke-width="2"></path>
            <text x="760" y="390" fill="black">O(n)</text>

            <path d="M50 450 Q 400 350, 800 150" fill="transparent" stroke="black" stroke-width="2"></path>
            <text x="630" y="190" fill="black">O(n log n)</text>

            <path d="M50 450 Q 180 380, 250 0" fill="transparent" stroke="black" stroke-width="2"></path>
            <text x="260" y="30" fill="black">O(n^2)</text>

            <path d="M50 450 C 100 430, 120 350, 120 0" fill="transparent" stroke="black" stroke-width="2"></path>
            <text x="125" y="20" fill="black">O(2^n)</text>

            <path d="M50 450 C 80 450, 80 350, 80 0" fill="transparent" stroke="black" stroke-width="2"></path>
            <text x="80" y="20" fill="black">O(n!)</text>

            <text x="0" y="0" transform="translate(30 230) rotate(-90)" style="dominant-baseline: middle; text-anchor: middle; font-size:20px; color: #555; font-size:20px; color: #555; font-style: italic;" fill="black">Operations</text>
            <text x="0" y="0" transform="translate(420 470)" style="dominant-baseline: middle; text-anchor: middle; font-size:20px; color: #555; font-style: italic;" fill="black">Elements</text>
          </svg>
        </div>
			</pre>
		</blockquote>

		<div>
			<h2><strong></strong></h2>
		</div>
			<div id="tablesWrapper">
				<h2 id="data-structures">Common Data Structure Operations</h2>
				<table class="table table-bordered table-striped">

					<tbody><tr>
						<th>Data Structure</th>
						<th colspan="8">Time Complexity</th>
						<th>Space Complexity</th>
					</tr>
					<tr>
						<th></th>
						<th colspan="4">Average</th>
						<th colspan="4">Worst</th>
						<th>Worst</th>
					</tr>
					<tr>
						<th></th>
						<th>Access</th>
						<th>Search</th>
						<th>Insertion</th>
						<th>Deletion</th>
						<th>Access</th>
						<th>Search</th>
						<th>Insertion</th>
						<th>Deletion</th>
						<th></th>
					</tr>

					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Array_data_structure">Array</a></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists">Singly-Linked List</a></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Doubly_linked_list">Doubly-Linked List</a></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="yellow">Θ(n)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="green">O(1)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Skip_list">Skip List</a></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="orange">O(n log(n))</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Hash_table">Hash Table</a></td>
						<td><code class="gray">N/A</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="green">Θ(1)</code></td>
						<td><code class="gray">N/A</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree</a></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="https://en.wikipedia.org/wiki/Cartesian_tree">Cartesian Tree</a></td>
						<td><code class="gray">N/A</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="gray">N/A</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/B_tree">B-Tree</a></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Red-black_tree">Red-Black Tree</a></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="https://en.wikipedia.org/wiki/Splay_tree">Splay Tree</a></td>
						<td><code class="gray">N/A</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="gray">N/A</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/K-d_tree">KD Tree</a></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow-green">Θ(log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>

					</tbody></table>

				<h2 id="sorting">Array Sorting Algorithms</h2>
				<table class="table table-bordered table-striped">
					<tbody><tr>
						<th>Algorithm</th>
						<th colspan="3">Time Complexity</th>
						<th>Space Complexity</th>
					</tr>
					<tr>
						<th></th>
						<th>Best</th>
						<th>Average</th>
						<th>Worst</th>
						<th>Worst</th>
					</tr>

					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Quicksort">Quicksort</a></td>
						<td><code class="orange">Ω(n log(n))</code></td>
						<td><code class="orange">Θ(n log(n))</code></td>
						<td><code class="red">O(n^2)</code></td>
						<td><code class="yellow-green">O(log(n))</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Merge_sort">Mergesort</a></td>
						<td><code class="orange">Ω(n log(n))</code></td>
						<td><code class="orange">Θ(n log(n))</code></td>
						<td><code class="orange">O(n log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Timsort">Timsort</a></td>
						<td><code class="yellow">Ω(n)</code></td>
						<td><code class="orange">Θ(n log(n))</code></td>
						<td><code class="orange">O(n log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Heapsort">Heapsort</a></td>
						<td><code class="orange">Ω(n log(n))</code></td>
						<td><code class="orange">Θ(n log(n))</code></td>
						<td><code class="orange">O(n log(n))</code></td>
						<td><code class="green">O(1)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a></td>
						<td><code class="yellow">Ω(n)</code></td>
						<td><code class="red">Θ(n^2)</code></td>
						<td><code class="red">O(n^2)</code></td>
						<td><code class="green">O(1)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a></td>
						<td><code class="yellow">Ω(n)</code></td>
						<td><code class="red">Θ(n^2)</code></td>
						<td><code class="red">O(n^2)</code></td>
						<td><code class="green">O(1)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Selection_sort">Selection Sort</a></td>
						<td><code class="red">Ω(n^2)</code></td>
						<td><code class="red">Θ(n^2)</code></td>
						<td><code class="red">O(n^2)</code></td>
						<td><code class="green">O(1)</code></td>
					</tr>
					<tr>
						<td><a href="https://en.wikipedia.org/wiki/Tree_sort">Tree Sort</a></td>
						<td><code class="orange">Ω(n log(n))</code></td>
						<td><code class="orange">Θ(n log(n))</code></td>
						<td><code class="red">O(n^2)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a href="http://en.wikipedia.org/wiki/Shellsort">Shell Sort</a></td>
						<td><code class="orange">Ω(n log(n))</code></td>
						<td><code class="red">Θ(n(log(n))^2)</code></td>
						<td><code class="red">O(n(log(n))^2)</code></td>
						<td><code class="green">O(1)</code></td>
					</tr>
					<tr>
						<td><a rel="tooltip" title="Only for integers. k is a number of buckets" href="http://en.wikipedia.org/wiki/Bucket_sort">Bucket Sort</a></td>
						<td><code class="green">Ω(n+k)</code></td>
						<td><code class="green">Θ(n+k)</code></td>
						<td><code class="red">O(n^2)</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>
					<tr>
						<td><a rel="tooltip" title="Constant number of digits 'k'" href="http://en.wikipedia.org/wiki/Radix_sort">Radix Sort</a></td>
						<td><code class="green">Ω(nk)</code></td>
						<td><code class="green">Θ(nk)</code></td>
						<td><code class="green">O(nk)</code></td>
						<td><code class="yellow">O(n+k)</code></td>
					</tr>
					<tr>
						<td><a rel="tooltip" title="Difference between maximum and minimum number 'k'" href="https://en.wikipedia.org/wiki/Counting_sort">Counting Sort</a></td>
						<td><code class="green">Ω(n+k)</code></td>
						<td><code class="green">Θ(n+k)</code></td>
						<td><code class="green">O(n+k)</code></td>
						<td><code class="yellow">O(k)</code></td>
					</tr>
					<tr>
						<td><a href="https://en.wikipedia.org/wiki/Cubesort">Cubesort</a></td>
						<td><code class="yellow">Ω(n)</code></td>
						<td><code class="orange">Θ(n log(n))</code></td>
						<td><code class="orange">O(n log(n))</code></td>
						<td><code class="yellow">O(n)</code></td>
					</tr>

					</tbody></table>
			</div>

			<div class="s-prose js-post-body" itemprop="text">
				<hr>
				<h3><strong>Quick note, my answer is almost certainly confusing <a href="http://en.wikipedia.org/wiki/Big_O_notation" rel="noreferrer">Big Oh notation</a> (which is an upper bound) with Big Theta notation "Θ" (which is a two-side bound). But in my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</strong></h3>
				<hr>
				<p>BigOh complexity can be visualized with this graph:</p>
				<p><a href="https://i.stack.imgur.com/WcBRI.png" rel="noreferrer"><img src="https://i.stack.imgur.com/WcBRI.png" alt="Big Oh Analysis"></a></p>
				<p>The simplest definition I can give for Big Oh notation is this:</p>
				<p><strong>Big Oh notation is a relative representation of the complexity of an algorithm.</strong></p>
				<p>There are some important and deliberately chosen words in that sentence:</p>
				<blockquote>
					<ul>
						<li><strong>relative:</strong> you can only compare apples to apples.  You can't compare an algorithm that does arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</li>
						<li><strong>representation:</strong> BigOh (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if the comparison is cheap but swapping is expensive?  It changes the comparison; and</li>
						<li><strong>complexity:</strong> if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</li>
					</ul>
				</blockquote>
				<p>Come back and reread the above when you've read the rest.</p>
				<p>The best example of BigOh I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learned in school were:</p>
				<blockquote>
					<ul>
						<li>addition;</li>
						<li>subtraction;</li>
						<li>multiplication; and</li>
						<li>division.</li>
					</ul>
				</blockquote>
				<p>Each of these is an operation or a problem.  A method of solving these is called an <strong>algorithm</strong>.</p>
				<p>The addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</p>
				<p>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add <strong>two</strong> 10,000 digit numbers we have to do 10,000 additions.</p>
				<p>See the pattern?  The <strong>complexity</strong> (being the number of operations) is directly proportional to the number of digits <em>n</em> in the larger number.  We call this <strong>O(n)</strong> or <strong>linear complexity</strong>.</p>
				<p>Subtraction is similar (except you may need to borrow instead of carry).</p>
				<p>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</p>
				<p>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10<sup>12</sup>) multiplications and two million adds.</p>
				<p>As the algorithm scales with n-<em>squared</em>, this is <strong>O(n<sup>2</sup>)</strong> or <strong>quadratic complexity</strong>. This is a good time to introduce another important concept:</p>
				<p><strong>We only care about the most significant portion of complexity.</strong></p>
				<p>The astute may have realized that we could express the number of operations as: n<sup>2</sup> + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</p>
				<p>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big Oh notation is about the Worst-case scenario of an algorithm.</p>
				<h1>The Telephone Book</h1>
				<p>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</p>
				<p>Now if you were instructing a computer to look up the phone number for "John Smith" in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</p>
				<p>A typical implementation might be to open up to the middle, take the 500,000<sup>th</sup> and compare it to "Smith". If it happens to be "Smith, John", we just got really lucky.  Far more likely is that "John Smith" will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</p>
				<p>This is called a <strong>binary search</strong> and is used every day in programming whether you realize it or not.</p>
				<p>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</p>
				<blockquote>
					<ul>
						<li>For a phone book of 3 names it takes 2 comparisons (at most).</li>
						<li>For 7 it takes at most 3.</li>
						<li>For 15 it takes 4.</li>
						<li>…</li>
						<li>For 1,000,000 it takes 20.</li>
					</ul>
				</blockquote>
				<p>That is staggeringly good, isn't it?</p>
				<p>In BigOh terms this is <strong>O(log n)</strong> or <strong>logarithmic complexity</strong>.  Now the logarithm in question could be ln (base e), log<sub>10</sub>, log<sub>2</sub> or some other base.  It doesn't matter it's still O(log n) just like O(2n<sup>2</sup>) and O(100n<sup>2</sup>) are still both O(n<sup>2</sup>).</p>
				<p>It's worthwhile at this point to explain that BigOh can be used to determine three cases with an algorithm:</p>
				<blockquote>
					<ul>
						<li><strong>Best Case:</strong> In the telephone book search, the best case is that we find the name in one comparison.  This is <strong>O(1)</strong> or <strong>constant complexity</strong>;</li>
						<li><strong>Expected Case:</strong> As discussed above this is O(log n); and</li>
						<li><strong>Worst Case:</strong> This is also O(log n).</li>
					</ul>
				</blockquote>
				<p>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</p>
				<p>Back to the telephone book.</p>
				<p>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</p>
				<p>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is <strong>unordered</strong> (by phone number anyway).</p>
				<p>So to find a name given the phone number (reverse lookup):</p>
				<blockquote>
					<ul>
						<li><strong>Best Case:</strong> O(1);</li>
						<li><strong>Expected Case:</strong> O(n) (for 500,000); and</li>
						<li><strong>Worst Case:</strong> O(n) (for 1,000,000).</li>
					</ul>
				</blockquote>
				<h1>The Traveling Salesman</h1>
				<p>This is quite a famous problem in computer science and deserves a mention.  In this problem, you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</p>
				<p>Sounds simple?  Think again.</p>
				<p>If you have 3 towns A, B, and C with roads between all pairs then you could go:</p>
				<blockquote>
					<ul>
						<li>A → B → C</li>
						<li>A → C → B</li>
						<li>B → C → A</li>
						<li>B → A → C</li>
						<li>C → A → B</li>
						<li>C → B → A</li>
					</ul>
				</blockquote>
				<p>Well, actually there's less than that because some of these are equivalent (A → B → C and C → B → A are equivalent, for example, because they use the same roads, just in reverse).</p>
				<p>In actuality, there are 3 possibilities.</p>
				<blockquote>
					<ul>
						<li>Take this to 4 towns and you have (iirc) 12 possibilities.</li>
						<li>With 5 it's 60.</li>
						<li>6 becomes 360.</li>
					</ul>
				</blockquote>
				<p>This is a function of a mathematical operation called a <strong>factorial</strong>.  Basically:</p>
				<blockquote>
					<ul>
						<li>5! = 5 × 4 × 3 × 2 × 1 = 120</li>
						<li>6! = 6 × 5 × 4 × 3 × 2 × 1 = 720</li>
						<li>7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040</li>
						<li>…</li>
						<li>25! = 25 × 24 × … × 2 × 1 = 15,511,210,043,330,985,984,000,000</li>
						<li>…</li>
						<li>50! = 50 × 49 × … × 2 × 1 = 3.04140932 × 10<sup>64</sup></li>
					</ul>
				</blockquote>
				<p>So the BigOh of the Traveling Salesman problem is <strong>O(n!)</strong> or <strong>factorial or combinatorial complexity</strong>.</p>
				<p><strong>By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.</strong></p>
				<p>Something to think about.</p>
				<h1>Polynomial Time</h1>
				<p>Another point I wanted to make a quick mention of is that any algorithm that has a complexity of <strong>O(n<sup>a</sup>)</strong> is said to have <strong>polynomial complexity</strong> or is solvable in <strong>polynomial time</strong>.</p>
				<p>O(n), O(n<sup>2</sup>) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. <a href="https://en.wikipedia.org/wiki/Public-key_cryptography" rel="noreferrer">Public Key Cryptography</a> is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</p>
				<p>Anyway, that's it for my (hopefully plain English) explanation of BigOh (revised).</p>
			</div>
		<div>
			<h2><strong></strong></h2>
		</div>
		<blockquote class="blockquote full-with">
			<p>There is an amazing tutorial for Big O in Youtube</p>
			<a class="media-button media-button-expand publisher-color publisher-border-color" href="https://www.youtube.com/watch?v=V6mKVRU1evU&amp;list=PLGLfVvz_LVvReUrWr94U-ZMgjYTQ538nT&amp;index=9" rel="nofollow" target="_blank" data-action="expand" title="YouTube – Big O Notations">
				<i class="icon-video publisher-background-color"></i>
				Play
			</a>
		</blockquote>


	</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js"></script>
<script src="../js/index.js"></script>
</body>
</html>
